以下是作者对该目录下文件的使用的简要介绍，未尽事宜，请多指教。
（1）
该目录下程序文件主要有三个：分别是AI.cpp（下文简称A程序）、Ovs_Process.cpp（下文简称O程序）、Packet_in_Process.cpp（下文简称P程序）。

使用流程：把原始数据文件放到指定的目录下，并稍微修改下原始文件中存在的问题（如果有的话，比如多余的空格等），然后运行P程序和O程序，得到处理后的数据。然后再运行A程序，得到可以和AI模块对接的数据。然后运行AIData.sql数据库脚本，建立数据库并将数据导入。最后根据AI模块所需要的文件格式导出（我们用的是csv格式）
功能：
P程序处理Packet_in数据包信息，进行单位时间内数据包变化率、熵值等的计算，然后把数据按照时间戳顺序放到一个文件夹下（注意此处由于有多个交换机的Packet_in信息，所以输出文件中先按交换机排序，再按时间戳排序（1））.
O程序处理和交换机有关的信息，生成三个输出文件，分别记录交换机信息、端口信息、通过该交换机的IP数据包信息。（此处也有多个交换机的信息，但此程序的输出文件中是按照时间戳排序的）
A程序处理P程序和O程序的输出结果，为了和AI模块的进行对接，把以上两个程序的输出结果中的时间戳改为一个从1开始递增的索引，之所以这么改是因为在和AI模块进行讨论的过程中，AI模块说索引比时间戳好处理。之所以没有一开始在O程序和P程序的结果文件中就生成索引和摒弃时间戳，是因为保留时间戳便于调试。
关于（1）的解释：之所以没有像O程序那样完全按照时间戳排序，是因为源数据的原因导致，原始数据中，packet_in数据是按照交换机分别存储的，而端口信息则是按照时间戳排好序的（即同一个时间戳下有多个交换机的信息）。所以，作者本人也就没有在P程序中额外加入排序功能（因为在处理大量数据时的效率问题）。但是，P程序针对不同的交换机会单独生成一个packet_in结果文件，在每个交换机单独的packet_in结果文件中是按照时间戳排序的。此处再加一个说明，如果项目需要，可自行添加排序功能。
注意：P程序会根据原始数据文件的个数（也即交换机的个数）产生相应数目的输出文件（分别对应每个交换机的Packet_in信息），这些文件可看作附带文件，对调试程序有用，给AI模块的数据，只给Packet_in_vector.txt中的数据即可。
（2）
对于文件路径的一些说明，该说明对于程序的移植很重要
由于原始数据以文件的形式提供，程序输出结果也以文件的形式存储。所以程序中有大量的文件操作。以上提到的三个程序文件中，即有使用相对路径，也有使用绝对路径。基本上是这样的情况：对单一文件的操作使用的是该文件的相对路径，对同一个目录下的所有文件的操作使用的是该目录的绝对路径。不管如何，文件路径一般都在宏定义或者主函数（main函数）里面，如果在自己的主机上运行，需要先修改文件路径。同时，关于应该怎么创建目录和文件，原始数据文件应该放在哪个目录下，程序文件应该放在什么目录下的问题，因为该问题虽然不复杂但一句两句话也说不清楚，而且对文件操作有一定了解的人都会（本人用的是C/C++文件函数），所以在此不做解释。只是提醒读者注意下面的例子，比如在Packet_in_source目录下的所有文件，P程序都会认为是原始数据文件。所以不要把P程序和原始数据文件放在一个目录下，也不要在该目录（Packet_in_source目录）下放一些乱七八糟的文件。
（3）
提醒注意time.txt文件，该文件存储每次脚本运行的开始时间，和一些随机的攻击时间段，这些随机的攻击时间段主要是自己写的脚本的攻击。数据集的攻击时间段是相对起始时间固定的。该文件的格式不同的人来做可能会不同，所以要在P程序和O程序中，根据time.txt文件修改相关的读取文件的代码。

（4）
对于在不同的环境下可能要在程序的基础上添加数据项的问题：比如Packet_in要加入一个新的特征（如数据包速率），或者交换机也要加入一个新的特征（比如TTL什么的）。有两种方式，第一种修改我的源程序，大概是在结构体中加入相应的变量，然后在文件读入和输出中加入相应的对该变量的操作。第二种是不修改我的程序，而另外写一个程序，将我程序的输出文件作为原始数据文件，然后增加相应操作，得到你相要的输出文件。

（5）
 以下是我写程序的一些记录，读者可略过：
于8月9日在Packet_in_Process(without index).cpp程序中加入了计算联合信息熵的功能：为了计算源IP和目的IP的联合信息熵，加入了一个map，在GainRecord函数中添加了相关代码，并且，在文件输出中，删除原来的端口熵，其在文件中的位置被联合信息熵占据，没有代码的删除。如果想要恢复到端口熵，只需将相应的输出进行修改。
注：后来该部分功能被注释掉，程序的功能和之前一样：计算IP熵和端口熵


8月15日修改，ovs_process。做一个连接，连接CPU信息到交换机，用一个向量，存储所有时刻的所有交换机的信息，每次写文件时，先查找向量，如果找到，则将对应的CPU信息写入文件，如果没找的，则CPU信息默认为0；（新加入logic3处理ovs_data源文件，加入了查找函数，修改了写交换机文件的代码，同时在原来的端口结构体中加入了time变量）。
